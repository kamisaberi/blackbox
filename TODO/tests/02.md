Here is the complete file structure for the **`blackbox-tests`** module.

This module is designed as a **standalone test suite**. It sits outside your source directories and pulls them in for verification. It includes a specific **CMake configuration** that builds the C++ tests independently from the main engine build.

### **1. Directory Structure**

```text
blackbox/
├── blackbox-core/             # (Existing Source)
├── blackbox-tower/            # (Existing Source)
└── blackbox-tests/            # [NEW MODULE]
    ├── README.md              # Instructions on how to run tests
    ├── run_all.sh             # Master script to run C++, Go, and Python tests
    │
    ├── core/                  # [C++ UNIT TESTS]
    │   ├── CMakeLists.txt     # Standalone Build Config for Tests
    │   ├── main.cpp           # GoogleTest Entry Point
    │   ├── fixtures/          # Mock data (vocab.txt, logs)
    │   │   ├── vocab.txt
    │   │   └── rules.yaml
    │   ├── ingest/
    │   │   ├── test_ring_buffer.cpp
    │   │   └── test_rate_limiter.cpp
    │   ├── parser/
    │   │   ├── test_parser_engine.cpp
    │   │   └── test_string_utils.cpp
    │   └── storage/
    │       └── test_clickhouse_client.cpp
    │
    ├── tower/                 # [GO INTEGRATION TESTS]
    │   ├── go.mod
    │   ├── main_test.go       # Test Main
    │   └── api/
    │       └── health_test.go # Hits the running API
    │
    └── sim/                   # [PYTHON LOGIC TESTS]
        ├── requirements.txt
        └── models/
            └── test_autoencoder.py
```

---

### **2. The C++ Build Config (`blackbox-tests/core/CMakeLists.txt`)**

This file is the magic. It reaches "backwards" (`../../`) to find your source code, downloads GoogleTest, and compiles a test binary without touching your main project.

```cmake
cmake_minimum_required(VERSION 3.20)
project(blackbox-tests CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# =========================================================
# 1. External Dependencies (GoogleTest)
# =========================================================
include(FetchContent)
FetchContent_Declare(
  googletest
  URL https://github.com/google/googletest/archive/refs/tags/v1.14.0.zip
)
# Prevent GTest from overriding parent compiler settings (Windows/Visual Studio specific mostly)
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

# =========================================================
# 2. Paths to Real Source Code
# =========================================================
set(CORE_ROOT "${CMAKE_SOURCE_DIR}/../../blackbox-core")
include_directories(${CORE_ROOT}/include)

# Dependencies required by the Core (Boost, etc.)
find_package(Boost REQUIRED COMPONENTS system)
find_package(Threads REQUIRED)
# We assume CURL/Hiredis are installed on the system via apt-get
find_package(CURL REQUIRED)

# =========================================================
# 3. Define the Test Sources
# =========================================================
# We compile the TEST files + the ACTUAL IMPLEMENTATION files they need.
# We do NOT link the 'flight-recorder' binary; we re-compile the objects.

set(TEST_SOURCES
    # --- Test Entry Point ---
    main.cpp

    # --- Unit Tests ---
    ingest/test_ring_buffer.cpp
    ingest/test_rate_limiter.cpp
    parser/test_string_utils.cpp

    # --- Actual Implementation Files (From Core) ---
    # We explicitly list only logic files (no main.cpp)
    ${CORE_ROOT}/src/ingest/ring_buffer.cpp
    ${CORE_ROOT}/src/ingest/rate_limiter.cpp
    ${CORE_ROOT}/src/common/string_utils.cpp
    ${CORE_ROOT}/src/common/logger.cpp
    ${CORE_ROOT}/src/common/time_utils.cpp
)

# =========================================================
# 4. Build Test Executable
# =========================================================
add_executable(run_core_tests ${TEST_SOURCES})

# Link Libraries
target_link_libraries(run_core_tests PRIVATE
    GTest::gtest_main
    Boost::system
    Threads::Threads
    ${CURL_LIBRARIES}
)

# Enable CTest
include(GoogleTest)
gtest_discover_tests(run_core_tests)
```

---

### **3. Sample C++ Test File (`blackbox-tests/core/ingest/test_ring_buffer.cpp`)**

```cpp
#include <gtest/gtest.h>
#include "blackbox/ingest/ring_buffer.h"
#include <string>

// Test Fixture
class RingBufferTest : public ::testing::Test {
protected:
    blackbox::ingest::RingBuffer<16> buffer; // Small buffer for testing
    blackbox::ingest::LogEvent event;
};

TEST_F(RingBufferTest, ShouldStartEmpty) {
    EXPECT_FALSE(buffer.pop(event));
}

TEST_F(RingBufferTest, ShouldPushAndPop) {
    std::string msg = "TestLog";
    EXPECT_TRUE(buffer.push(msg.c_str(), msg.length()));

    EXPECT_TRUE(buffer.pop(event));
    std::string result(event.raw_data, event.length);
    EXPECT_EQ(result, "TestLog");
}

TEST_F(RingBufferTest, ShouldDropWhenFull) {
    std::string msg = "A";

    // Fill buffer (Capacity - 1 is typically usable in lock-free ring buffers)
    for(int i=0; i<16; i++) {
        buffer.push(msg.c_str(), 1);
    }

    // This push should fail
    EXPECT_FALSE(buffer.push(msg.c_str(), 1));
}
```

---

### **4. Sample Go Test (`blackbox-tests/tower/api/health_test.go`)**

```go
package api_test

import (
	"net/http"
	"testing"
	"time"
)

// This assumes blackbox-tower is running via Docker
func TestHealthEndpoint(t *testing.T) {
	client := &http.Client{Timeout: 2 * time.Second}

	resp, err := client.Get("http://localhost:8080/api/v1/health")
	if err != nil {
		t.Fatalf("Failed to call API: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		t.Errorf("Expected status 200, got %d", resp.StatusCode)
	}
}
```

---

### **5. The Master Script (`blackbox-tests/run_all.sh`)**

```bash
#!/bin/bash
set -e # Exit on error

echo "========================================"
echo "   BLACKBOX AUTOMATED TESTING SUITE"
echo "========================================"

# 1. C++ Core Tests
echo -e "\n>>> [1/3] Running C++ Core Unit Tests..."
cd core
if [ ! -d "build" ]; then
    mkdir build
fi
cd build
cmake ..
make -j4
./run_core_tests
cd ../..

# 2. Python Sim Tests
echo -e "\n>>> [2/3] Running Python Sim Tests..."
# Assumes python3 and pytest are installed
if command -v pytest &> /dev/null; then
    pytest sim/
else
    echo "[WARN] pytest not found, skipping Python tests."
fi

# 3. Go Tower Tests
echo -e "\n>>> [3/3] Running Go API Tests..."
cd tower
if command -v go &> /dev/null; then
    go test ./...
else
    echo "[WARN] go not found, skipping API tests."
fi
cd ..

echo -e "\n✅ ALL TESTS PASSED."
```

### **How to Use**

1.  Create the directory structure.
2.  Populate the `CMakeLists.txt` and source files.
3.  Make the script executable: `chmod +x blackbox-tests/run_all.sh`.
4.  Run `./blackbox-tests/run_all.sh`.

This structure keeps your testing logic **completely clean** and separate from your production code, while still compiling against the real logic for accuracy.