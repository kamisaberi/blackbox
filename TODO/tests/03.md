Here are the implementation codes for the remaining test files listed in the structure.

These tests cover **Core Logic** (C++) and **AI Logic** (Python).

---

### **1. The C++ Test Runner (`blackbox-tests/core/main.cpp`)**
**Role:** The entry point for GoogleTest. It initializes the testing framework.

```cpp
/**
 * @file main.cpp
 * @brief GoogleTest Entry Point.
 */

#include <gtest/gtest.h>
#include "blackbox/common/logger.h"

int main(int argc, char **argv) {
    // 1. Initialize GoogleTest
    ::testing::InitGoogleTest(&argc, argv);

    // 2. Configure Blackbox Logger for tests
    // We set it to ERROR only so normal INFO logs don't clutter test output
    blackbox::common::Logger::instance().set_level(blackbox::common::LogLevel::ERROR);

    // 3. Run All Tests
    return RUN_ALL_TESTS();
}
```

---

### **2. Rate Limiter Test (`blackbox-tests/core/ingest/test_rate_limiter.cpp`)**
**Role:** Verifies the Token Bucket algorithm logic.

```cpp
#include <gtest/gtest.h>
#include "blackbox/ingest/rate_limiter.h"
#include <thread>
#include <chrono>

class RateLimiterTest : public ::testing::Test {
    // Helper to reset singleton state if possible,
    // but since RateLimiter is a Singleton, we must assume shared state.
    // We use unique IPs to ensure isolation between tests.
};

TEST_F(RateLimiterTest, ShouldAllowBurst) {
    auto& limiter = blackbox::ingest::RateLimiter::instance();
    std::string ip = "10.0.0.1";

    // The default burst is usually 500.
    // We should be able to send 10 packets instantly.
    for(int i = 0; i < 10; ++i) {
        EXPECT_TRUE(limiter.should_allow(ip)) << "Packet " << i << " blocked unexpectedly";
    }
}

TEST_F(RateLimiterTest, ShouldBlockExcessiveTraffic) {
    auto& limiter = blackbox::ingest::RateLimiter::instance();
    std::string ip = "10.0.0.2";

    // Drain the bucket (assuming burst is ~500)
    int allowed = 0;
    for(int i = 0; i < 1000; ++i) {
        if(limiter.should_allow(ip)) allowed++;
    }

    // We expect some to pass and some to fail
    EXPECT_LT(allowed, 1000) << "Rate limiter did not block any packets";

    // Immediate subsequent packet should fail
    EXPECT_FALSE(limiter.should_allow(ip)) << "Bucket should be empty";
}

TEST_F(RateLimiterTest, ShouldRefillOverTime) {
    auto& limiter = blackbox::ingest::RateLimiter::instance();
    std::string ip = "10.0.0.3";

    // 1. Drain bucket
    while(limiter.should_allow(ip));
    EXPECT_FALSE(limiter.should_allow(ip));

    // 2. Wait (e.g., 100ms)
    // Refill rate is 100/sec -> 0.1/ms -> 10 tokens in 100ms
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    // 3. Should allow again
    EXPECT_TRUE(limiter.should_allow(ip)) << "Bucket did not refill after wait";
}
```

---

### **3. String Utils Test (`blackbox-tests/core/parser/test_string_utils.cpp`)**
**Role:** Verifies string manipulation and SQL escaping (Security).

```cpp
#include <gtest/gtest.h>
#include "blackbox/common/string_utils.h"

using blackbox::common::StringUtils;

TEST(StringUtilsTest, Trim) {
    EXPECT_EQ(StringUtils::trim("  hello  "), "hello");
    EXPECT_EQ(StringUtils::trim("hello"), "hello");
    EXPECT_EQ(StringUtils::trim("   "), "");
    EXPECT_EQ(StringUtils::trim("\t\nhello\n"), "hello");
}

TEST(StringUtilsTest, Split) {
    auto parts = StringUtils::split("user,pass,ip", ',');
    ASSERT_EQ(parts.size(), 3);
    EXPECT_EQ(parts[0], "user");
    EXPECT_EQ(parts[1], "pass");
    EXPECT_EQ(parts[2], "ip");

    auto single = StringUtils::split("noseparator", ',');
    ASSERT_EQ(single.size(), 1);
    EXPECT_EQ(single[0], "noseparator");
}

TEST(StringUtilsTest, SQLEscape) {
    std::string input = "O'Reilly";
    std::string expected = "O\\'Reilly";
    EXPECT_EQ(StringUtils::escape_sql(input), expected);

    std::string injection = "admin'; DROP TABLE logs;--";
    std::string safe = StringUtils::escape_sql(injection);
    // Ensure single quote is escaped
    EXPECT_NE(safe.find("\\'"), std::string::npos);
}

TEST(StringUtilsTest, StartsWith) {
    EXPECT_TRUE(StringUtils::starts_with("HELLO AGENT", "HELLO"));
    EXPECT_FALSE(StringUtils::starts_with("HELLO AGENT", "hello")); // Case sensitive
    EXPECT_FALSE(StringUtils::starts_with("HI", "HELLO"));
}
```

---

### **4. Parser Engine Test (`blackbox-tests/core/parser/test_parser_engine.cpp`)**
**Role:** Verifies logic extraction.
*Note: Since ParserEngine loads config files in its constructor, we must create dummy files during test setup.*

```cpp
#include <gtest/gtest.h>
#include <fstream>
#include <filesystem>
#include "blackbox/parser/parser_engine.h"
#include "blackbox/common/settings.h"

class ParserEngineTest : public ::testing::Test {
protected:
    void SetUp() override {
        // 1. Create dummy config directories
        std::filesystem::create_directories("config");

        // 2. Create dummy vocab.txt
        std::ofstream vocab("config/vocab.txt");
        vocab << "failed\npassword\nroot\n"; // 0, 1, 2
        vocab.close();

        // 3. Create dummy scaler_params.txt (128 lines)
        std::ofstream scaler("config/scaler_params.txt");
        for(int i=0; i<128; i++) scaler << "0.0,1.0\n";
        scaler.close();

        // 4. Update Settings singleton to point to these files
        // (Assuming we can modify settings via env vars or direct access,
        //  here we rely on defaults matching 'config/')
    }

    void TearDown() override {
        std::filesystem::remove_all("config");
    }
};

TEST_F(ParserEngineTest, ParseSyslog) {
    blackbox::parser::ParserEngine parser;
    blackbox::ingest::LogEvent event;

    // Mock Syslog Message: <PRI>VER TS HOST APP PID MSGID SD MSG
    std::string raw_log = "<34>1 2023-10-10T00:00:00Z my-laptop sshd - - - Failed password for root";

    // Copy to event buffer
    std::memcpy(event.raw_data, raw_log.c_str(), raw_log.size());
    event.length = raw_log.size();
    event.timestamp_ns = 1000;

    auto result = parser.process(event);

    EXPECT_EQ(result.host, "my-laptop");
    EXPECT_EQ(result.service, "sshd");
    EXPECT_EQ(result.message, "Failed password for root");
    EXPECT_FALSE(result.id.empty()); // UUID generated
}

TEST_F(ParserEngineTest, ParseGarbage) {
    blackbox::parser::ParserEngine parser;
    blackbox::ingest::LogEvent event;

    std::string raw_log = "Just random garbage text";
    std::memcpy(event.raw_data, raw_log.c_str(), raw_log.size());
    event.length = raw_log.size();

    auto result = parser.process(event);

    // Should fallback
    EXPECT_EQ(result.service, "raw");
    EXPECT_EQ(result.message, "Just random garbage text");
}
```

---

### **5. Python Autoencoder Test (`blackbox-tests/sim/models/test_autoencoder.py`)**
**Role:** Verifies the PyTorch model architecture dimensions.

```python
import unittest
import torch
import sys
import os

# Add src to path to allow import
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../blackbox-sim')))

from src.models.autoencoder import LogAutoencoder

class TestAutoencoder(unittest.TestCase):
    def setUp(self):
        self.input_dim = 128
        self.model = LogAutoencoder(input_dim=self.input_dim)

    def test_dimensions(self):
        """Test if output shape matches input shape"""
        batch_size = 10
        dummy_input = torch.randn(batch_size, self.input_dim)

        output = self.model(dummy_input)

        self.assertEqual(output.shape, (batch_size, self.input_dim))

    def test_values_range(self):
        """Test if Sigmoid activation keeps output between 0 and 1"""
        dummy_input = torch.randn(5, self.input_dim)
        output = self.model(dummy_input)

        self.assertTrue((output >= 0).all())
        self.assertTrue((output <= 1).all())

if __name__ == '__main__':
    unittest.main()
```

---

### **Summary**

You now have the full source code for the testing suite.
1.  **C++ Runners:** `main.cpp`
2.  **C++ Unit Tests:** `test_rate_limiter.cpp`, `test_string_utils.cpp`, `test_parser_engine.cpp`
3.  **Python Tests:** `test_autoencoder.py`

Run `blackbox-tests/run_all.sh` to execute them all.